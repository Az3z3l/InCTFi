from Crypto.Util.number import *
from Crypto.PublicKey import RSA
from pwn import *

def lsbitoracle(flag_enc, _decrypt, e, N, upper_limit, lower_limit):
    """
    Reference: https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack

    Function implementing LSBit Oracle Attack

    Warning: Function does not return the last byte of the final plaintext

    :Input parameters:
    flag_enc   : <type 'str'>     : Ciphertext you want to decrypt
    _decrypt   : <type 'function'>: Function interacting with the server for decryption
    e          : <type 'int'>     : Public key exponent
    N          : <type 'long'>    : Modulus
    upper_limit: <type 'long'>    : Maximum value of corresponding plaintext of flag_enc
    lower_limit: <type 'long'>    : Minimum value of corresponding plaintext of flag_enc

    Since the attack messes up with the last byte of the plaintext, lsbitoracle
    function returns only flag[:-1]. It returns -1 in case of any Exception
    """
    flag = ""
    i = 1
    while lower_limit < upper_limit:
        chosen_ct = long_to_bytes((bytes_to_long(flag_enc)*pow(2**i, e, N)) % N)
        output = _decrypt(chosen_ct)
        print ord(output)
        if ord(output[-1]) == 0:
            upper_limit = (upper_limit + lower_limit)/2
        elif ord(output[-1]) == 1:
            lower_limit = (lower_limit + upper_limit)/2
        else:
            return -1
        i += 1
    print "i: ", i
    # clearing the last byte from the flag
    flag = lower_limit & (~0xff)
    return long_to_bytes(flag)

def _encrypt(message):
    r.recvuntil("choice: ")
    r.sendline("1")
    r.recvuntil("to encrypt (in hex): ")
    r.sendline(message.encode("hex"))
    ct = r.recvline("ciphertext (in hex): ").strip()[37:]
    r.recvline()
    r.recvline()
    return ct.decode("hex")

def _decrypt(ciphertext):
    r.recvuntil("choice: ")
    r.sendline("2")
    r.recvuntil("to decrypt (in hex): ")
    r.sendline(ciphertext.encode("hex"))
    pt = r.recvline("plaintext (in hex): ").strip()[36:]
    r.recvline()
    r.recvline()
    return pt.decode("hex")

r = process("./run.sh")
r.recvline()
flag_enc = r.recvline().strip()[31:].decode("hex")
N = int(r.recvline().strip()[20:])
print "flag_enc: ", flag_enc
print "N: ", N
print "\n\n"

e = 65537
upper_limit = N
lower_limit = 0

flag = ""
# i = 1
# while i <= 1034:
#     chosen_ct = long_to_bytes((bytes_to_long(flag_enc)*pow(2**i, e, N)) % N)
#     output = _decrypt(chosen_ct)
#     if ord(output[-1]) == 0:
#         upper_limit = (upper_limit + lower_limit)/2
#     elif ord(output[-1]) == 1:
#         lower_limit = (lower_limit + upper_limit)/2
#     else:
#         print "bhak"
#     i += 1
#
# print "Flag : ", long_to_bytes(lower_limit)
# print "Last byte cleared: ", long_to_bytes(lower_limit & (~0xff))
print "Here take your flag: ", lsbitoracle(flag_enc, _decrypt, e, N, upper_limit, lower_limit)
